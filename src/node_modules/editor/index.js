const CodeMirror = require('codemirror')
const { remote } = require('electron')
var npm = require('npm')

const getInstalledPackages = () => {
  return new Promise((resolve, reject) => {
    npm.load({ '--depth': 0 }, function(err) {
      // handle errors
      if (err) {
        return reject(err)
      }

      // install module ffi
      npm.commands.list([], function(er, data) {
        // log errors or data
        if (er) return reject(er)
        resolve(Object.keys(data.dependencies))
      })

      npm.on('log', function(message) {
        // log installation progress
        // console.log('npm i', message)
      })
    })
  })
}

var installedPackages = getInstalledPackages()

require('codemirror/mode/javascript/javascript')
require('codemirror/addon/edit/matchbrackets')

const opts = {
  lineNumbers: JSON.parse(window.localStorage.lineNumbers || 'false'),
  styleActiveLine: false,
  matchBrackets: true,
  theme: window.localStorage.theme || 'light'
}

document.body.setAttribute('data-theme', opts.theme.toLowerCase())

const editor = CodeMirror.fromTextArea(
  document.getElementById('editor'),
  Object.assign({}, opts, {
    autofocus: true,
    mode: 'jsx',
    gutters: ['CodeMirror-lint-markers'],
    lint: true
  })
)

const output = CodeMirror.fromTextArea(
  document.getElementById('output'),
  Object.assign({}, opts, { readOnly: true })
)

setTimeout(() => {
  editor.refresh()
  output.refresh()
}, 128)

let sandbox = new remote.BrowserWindow({
  width: 450,
  height: 400,
  minWidth: 150,
  minHeight: 200,
  title: 'Document Window'
})

sandbox.loadURL(`file://${__dirname}/../../../static/blank.html`)

sandbox.webContents.on('did-finish-load', () => {
  const str = window.localStorage.input || ''
  editor.setValue(str)
  render(str)
})

if (!window.localStorage.sandbox) {
  sandbox.hide()
}

async function render(s) {
  window.localStorage.input = s

  s = s.replace(/`/g, '\\`').replace(/\${/g, '\\${')

  s = s
    .split('\n')
    .map((line, lineno) => {
      return line.replace(/console\.log\(/g, () => {
        return `console.log(${lineno}, `
      })
    })
    .join('\n')

  const builtins = [
    'assert',
    'async_hooks',
    'buffer',
    'child_process',
    'cluster',
    'console',
    'constants',
    'crypto',
    'dgram',
    'dns',
    'domain',
    'events',
    'fs',
    'http',
    'http2',
    'https',
    'inspector',
    'module',
    'net',
    'os',
    'path',
    'perf_hooks',
    'process',
    'punycode',
    'querystring',
    'readline',
    'repl',
    'stream',
    'string_decoder',
    'timers',
    'tls',
    'tty',
    'url',
    'util',
    'v8',
    'vm',
    'zlib'
  ]

  const isBuiltIn = name => builtins.includes(name)
  const isInstalled = name =>
    installedPackages.then(packages => packages.includes(name))

  const l = s.match(/require(.*)/g)
  const m = !l
    ? []
    : l
        .map(r => {
          const [start, mod, end] = r.split("'")
          return mod
        })
        .map(mod => ({
          name: mod,
          isBuiltIn: isBuiltIn(mod),
          isInstalled: isInstalled(mod)
        }))

  const getJSpkg = url => fetch(url).then(r => r.text())
  const installPkg = name => {
    return !name
      ? null
      : new Promise((resolve, reject) => {
          npm.load(function(err) {
            // handle errors
            if (err) return reject(err)
            console.log(`Installing ${name} ...`)
            // install module ffi
            npm.commands.install([name], function(er, data) {
              // log errors or data
              if (er) return reject(er)
              console.log(`Installed ${name}!`)
              resolve(data)
            })
          })
        }).then(_ => {
          installedPackages = installedPackages.then(packages =>
            packages.slice(0).push(name)
          )
        })
  }

  const mods = m.map(mod => {
    return Object.assign({}, mod, {
      namespace: `__pkg__${mod.name}`,
      promise: !mod.isBuiltIn
        ? mod.isInstalled
            .then(isInstalled => (!isInstalled ? installPkg(mod.name) : null))
            .then(_ => mod.name)
        : null
    })
  })

  const wait = duration =>
    new Promise((res, rej) => {
      setTimeout(_ => res(undefined), duration)
    })

  const all = Promise.all(mods.map(m => m.promise))

  Promise.race([wait(500), all]).then(r => {
    if (!r) {
      output.setValue(
        `Loading modules [${mods.map(m => m.name).join(', ')}] ...`
      )
      sandbox.webContents.executeJavaScript(`
        document.body.innerHTML = 'Loading modules [${mods
          .map(m => m.name)
          .join(',')}] ...
      `)
    }
  })

  let ready = await all
  console.log('ready', JSON.stringify(ready))

  let result = await sandbox.webContents.executeJavaScript(`
    window.__output = []

    try {
      eval(\`(function() { ${s}; })()\`)

      window.__output
    } catch (ex) {
      ex.stack
    }
  `)

  // console.log(result)

  if (typeof result === 'string') {
    if (/SyntaxError: Unexpected token ;/.test(result)) return

    const lines = result.split('\n').slice(0, -4)
    const message = lines.shift()
    const stack = lines
      .map(line => {
        const info = line.split(' ')
        return `  at ${info[info.length - 1].slice(0, -1)}`
      })
      .join('\n')

    return output.setValue([message, stack].join('\n'))
  }

  if (result.length === 0) {
    return output.setValue('')
  }

  result = result.filter(Boolean)

  result = result.map(chunk => {
    const line = parseInt(chunk.split(' ')[0], 10)
    const content = chunk.replace(/^\d+ /, '')
    return { line, content }
  })

  if (window.localStorage.matchingLines) {
    const last = result[result.length - 1].line
    output.setValue(
      Array(last || 1)
        .fill('\n')
        .join('')
    )

    result.forEach(chunk => {
      const content = chunk.content.replace(/\\n/g, '\n')
      output.replaceRange(content, { line: chunk.line })
    })
  } else {
    output.setValue(result.map(chunk => chunk.content).join('\n'))
  }
}

let renderTimeout = null

editor.on('change', event => {
  const str = editor.getValue()
  clearTimeout(renderTimeout)
  renderTimeout = setTimeout(() => render(str), 512)
})

//
// Window events
//
window.events.on('matchinglines', () => {
  if (window.localStorage.matchingLines) {
    delete window.localStorage.matchingLines
  } else {
    window.localStorage.matchingLines = true
  }
  render(editor.getValue())
})

window.events.on('sandbox', () => {
  if (window.localStorage.sandbox) {
    sandbox.hide()
    delete window.localStorage.sandbox
  } else {
    sandbox.show()
    window.localStorage.sandbox = true
  }
})

window.events.on('editor:theme', name => {
  name = name.toLowerCase()
  document.body.setAttribute('data-theme', name)
  editor.setOption('theme', name)
  output.setOption('theme', name)
})

window.events.on('editor:linenumbers', () => {
  const state = (opts.lineNumbers = !opts.lineNumbers)
  window.localStorage.lineNumbers = state
  editor.setOption('lineNumbers', state)
  output.setOption('lineNumbers', state)
})
